// This combined test file was generated by running the script `doxytest.py` to extract tests from comments in input files.
// Input file(s): `formatter.h`, `macros.h`, `string.h`, `thousands.h`
// Do not edit this file manually -- it may be overwritten.
// Generated on: 2025-10-30 12:53:15

#include "../include/utilities/formatter.h"
#include "../include/utilities/macros.h"
#include "../include/utilities/string.h"
#include "../include/utilities/thousands.h"
#include <cstdlib>
#include <exception>
#include <format>
#include <print>
#include <source_location>
#include <string>
#include <string_view>
#include <tuple>
#include <type_traits>
#include <utility>
#include <vector>
#include <utilities/namespace.h>

// We use our own assert macros instead of the standard ones.
#ifdef assert
    #undef assert
#endif
#ifdef assert_eq
    #undef assert_eq
#endif

#define assert(cond, ...) \
    if(!(cond)) doxy::failed(#cond, header_file, header_line __VA_OPT__(, __VA_ARGS__));

#define assert_eq(a, b, ...) \
    if(!((a) == (b))) doxy::failed_eq(#a, #b, (a), (b), header_file, header_line __VA_OPT__(, __VA_ARGS__));

namespace doxy {

// Maximum number of allowed failures before we exit the program.
std::size_t max_fails = 10;

// A simple exception class for test failures.
struct error : public std::exception {
    explicit error(std::string message) : m_message(std::move(message)) {}
    const char* what() const noexcept override { return m_message.c_str(); }
    std::string m_message;
};

// Program exit (possibly break in `doxy::exit` if you are debugging a test failure).
void exit(int status) { ::exit(status); }

// Handle boolean condition assertion evaluation failures.
template <typename... Args>
void
failed(std::string_view cond_str, std::string_view hdr_file, std::size_t hdr_line, 
       std::string_view msg_format = "", Args&&... msg_args) {
    auto what = std::format("\nFAILED `assert({})` [{}:{}]\n", cond_str, hdr_file, hdr_line);
    if (!msg_format.empty()) {
        auto arg_storage = std::tuple<std::decay_t<Args>...>(std::forward<Args>(msg_args)...);
        auto format_args = std::apply([](auto&... values) { return std::make_format_args<std::format_context>(values...); }, arg_storage);
        what += std::vformat(msg_format, format_args);
        what.push_back('\n');
    }
    throw error{std::move(what)};
}

// Handle equality assertion evaluation failures.
template <typename LHS, typename RHS, typename... Args>
void
failed_eq(std::string_view lhs_str, std::string_view rhs_str, const LHS& lhs, const RHS& rhs,
          std::string_view hdr_file, std::size_t hdr_line, std::string_view msg_format = "", Args&&... msg_args) {
    auto what = std::format("\nFAILED `assert_eq({}, {})` [{}:{}]\n", lhs_str, rhs_str, hdr_file, hdr_line);
    if (!msg_format.empty()) {
        auto arg_storage = std::tuple<std::decay_t<Args>...>(std::forward<Args>(msg_args)...);
        auto format_args = std::apply([](auto&... values) { return std::make_format_args<std::format_context>(values...); }, arg_storage);
        what += std::vformat(msg_format, format_args);
        what.push_back('\n');
    }
    what += std::format("lhs = {}\n", lhs);
    what += std::format("rhs = {}\n", rhs);
    throw error{std::move(what)};
}

} // namespace doxy

int
main() {
    auto header_count = 4;
    std::size_t test_count = 42;
    std::println(stderr, "Running {} tests extracted from {} input files.", test_count, header_count);

    // Number of failed doctests (we exit the program if this exceeds doxy::max_fails).
    std::size_t fails = 0;

    // Variables used to track the current test.
    std::string_view header_file;
    std::size_t header_line = 0;
    std::size_t test = 0;
    auto test_passed = true;

    // Cache of all failed test messages.
    std::vector<std::string> failed_messages;

    // Each test failure is handled the same way:
    auto handle_failure = [&](std::string_view message) {
        test_passed = false;
        fails++;
        std::println(stderr, "FAIL");
        std::println(stderr, "{}", message);
        failed_messages.push_back(std::string(message));
        if (fails >= doxy::max_fails) {
            std::println(stderr);
            std::println(stderr, "Hit the maximum allowed number of failures ({}) for the combined test file:", doxy::max_fails);
            std::println(stderr, "Managed to run {} of a possible {} tests, PASSED: {}, FAILED: {}", test, test_count, test - fails, fails);
            std::println(stderr, "Here is a summary of the failed tests:");
            for (const auto& msg : failed_messages) std::print(stderr, "{}", msg);
            doxy::exit(1);
        };
    };
    header_file = "formatter.h";
    // Run the tests ...
    header_line = 27;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        struct Whatever {
            std::string to_string() const { return "Whatever!"; }
        };
        Whatever whatever;
        auto whatever_str = std::format("{}", whatever);
        assert_eq(whatever_str, "Whatever!");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_file = "macros.h";
    // Run the tests ...
    header_line = 54;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        #define FOO1 "abc"
        #define BAR1 FOO1
        auto s = STRINGISE(BAR1);
        assert(std::strcmp(s, "abc") == 0, "s = {}", s);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 66;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        #define FOO2 foo
        #define BAR2 FOO2
        int foofoo = 42;
        auto value = CONCAT(FOO2, BAR2);
        assert(value == foofoo);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 79;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        #define major 3
        #define minor 2
        #define patch 1
        auto s3 = VERSION_STRING(major, minor, patch);
        auto s2 = VERSION_STRING(major, minor);
        auto s1 = VERSION_STRING(major);
        assert(std::strcmp(s3, "3.2.1") == 0);
        assert(std::strcmp(s2, "3.2") == 0);
        assert(std::strcmp(s1, "3") == 0);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_file = "string.h";
    // Run the tests ...
    header_line = 31;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert(utilities::to_upper('a') == 'A');
        assert(utilities::to_upper('z') == 'Z');
        assert(utilities::to_upper('A') == 'A');
        assert(utilities::to_upper('Z') == 'Z');
        assert(utilities::to_upper('=') == '=');
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 49;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        assert(utilities::to_lower('A') == 'a');
        assert(utilities::to_lower('Z') == 'z');
        assert(utilities::to_lower('a') == 'a');
        assert(utilities::to_lower('z') == 'z');
        assert(utilities::to_lower('=') == '=');
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 68;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::string str = "Hello, World!";
        utilities::upper_case(str);
        assert_eq(str, "HELLO, WORLD!");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 87;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::string str = "HELLO, WORLD!";
        utilities::lower_case(str);
        assert_eq(str, "hello, world!");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 103;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::string str = "  Hello, World!";
        utilities::trim_left(str);
        assert_eq(str, "Hello, World!");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 117;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::string str = "Hello, World!  ";
        utilities::trim_right(str);
        assert_eq(str, "Hello, World!");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 131;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::string str = "  Hello, World!  ";
        utilities::trim(str);
        assert_eq(str, "Hello, World!");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 146;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::string str = "Hello, World!";
        utilities::replace_left(str, "World", "Universe");
        assert_eq(str, "Hello, Universe!");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 161;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::string str = "Hello, World!";
        utilities::replace_right(str, "World", "Universe");
        assert_eq(str, "Hello, Universe!");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 176;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::string str = "Hello, World! Hello, Universe!";
        utilities::replace(str, "Hello", "Goodbye");
        assert_eq(str, "Goodbye, World! Goodbye, Universe!");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 199;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::string str = "    Hello   World!  ";
        utilities::replace_space(str);
        assert_eq(str, "Hello World!");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 218;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::string str = "Hello,   World!  ";
        utilities::condense(str);
        assert_eq(str, "Hello, World!");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 232;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::string str = "Hello, World!";
        utilities::erase_left(str, "World");
        assert_eq(str, "Hello, !");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 247;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::string str = "Hello, World!";
        utilities:: erase_right(str, "World");
        assert_eq(str, "Hello, !");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 262;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::string str = "abcdefghijklmnopqrstuvwxyz";
        utilities::erase(str, "def");
        assert_eq(str, "abcghijklmnopqrstuvwxyz");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 280;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::string str = "(Hello, World!)";
        utilities::remove_surrounds(str);
        assert_eq(str, "Hello, World!");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 333;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::string str = "[ hallo   world ]  ";
        utilities::standardize(str);
        assert_eq(str, "HALLO WORLD");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 357;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::string str = "Hello, World!";
        auto upper_str = utilities::upper_cased(str);
        assert_eq(upper_str, "HELLO, WORLD!");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 375;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::string str = "Hello, World!";
        auto lower_str = utilities::lower_cased(str);
        assert_eq(lower_str, "hello, world!");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 391;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::string str = "  Hello, World!";
        auto trimmed_left_str = utilities::trimmed_left(str);
        assert_eq(trimmed_left_str, "Hello, World!");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 407;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::string str = "Hello, World!  ";
        auto trimmed_right_str = utilities::trimmed_right(str);
        assert_eq(trimmed_right_str, "Hello, World!");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 423;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::string str = "  Hello, World!  ";
        auto trimmed_str = utilities::trimmed(str);
        assert_eq(trimmed_str, "Hello, World!");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 439;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::string str = "Hello, World!";
        auto replaced_str = utilities::replaced_left(str, "World", "Universe");
        assert_eq(replaced_str, "Hello, Universe!");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 455;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::string str = "Hello, World!";
        auto replaced_str = utilities::replaced_right(str, "World", "Universe");
        assert_eq(replaced_str, "Hello, Universe!");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 471;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::string str = "Hello World! Hello Universe!";
        auto replaced_str = utilities::replaced(str, "Hello", "Goodbye");
        assert_eq(replaced_str, "Goodbye World! Goodbye Universe!");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 491;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::string str = "  Hello    World!  ";
        auto replaced_space_str = utilities::replaced_space(str);
        assert_eq(replaced_space_str, "Hello World!");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 510;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::string str = "Hello,   World!  ";
        auto condensed_str = utilities::condensed(str);
        assert_eq(condensed_str, "Hello, World!");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 526;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::string str = "Hello, World!";
        auto erased_left_str = utilities::erased_left(str, "World");
        assert_eq(erased_left_str, "Hello, !");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 542;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::string str = "Hello, World!";
        auto erased_right_str = utilities::erased_right(str, "World");
        assert_eq(erased_right_str, "Hello, !");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 558;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::string str = "abcdefghijklmnopqrstuvwxyz";
        auto erased_str = utilities::erased(str, "def");
        assert_eq(erased_str, "abcghijklmnopqrstuvwxyz");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 577;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::string str = "(Hello, World!)";
        auto removed_surrounds_str = utilities::removed_surrounds(str);
        assert_eq(removed_surrounds_str, "Hello, World!");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 595;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::string str = "[ hallo world ]";
        auto standardized_str = utilities::standardized(str);
        assert_eq(standardized_str, "HALLO WORLD");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 615;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::string str = "Hello, World!";
        bool starts_with_hello = utilities::starts_with(str, "Hello");
        assert_eq(starts_with_hello, true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 629;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::string str = "Hello, World!";
        bool ends_with_world = utilities::ends_with(str, "World!");
        assert_eq(ends_with_world, true);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 646;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::string str = "123.456";
        auto x = utilities::possible<double>(str);
        assert_eq(*x, 123.456);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 692;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::string str = "Hello, World";
        std::vector<std::string> tokens;
        utilities::tokenize(str, tokens);
        std::vector<std::string> expected = {"Hello", "World"};
        assert_eq(tokens, expected);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_line = 720;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        std::string str = "Hello, World";
        auto tokens = utilities::split(str);
        std::vector<std::string> expected = {"Hello", "World"};
        assert_eq(tokens, expected);
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    header_file = "thousands.h";
    // Run the tests ...
    header_line = 58;
    test_passed = true;
    std::print(stderr, "test {}/{} ({}:{}) ... ", ++test, test_count, header_file, header_line);
    try {
        utilities::pretty_print_thousands();
        auto x_str = std::format("x = {:L}", 123456789.9);
        assert_eq(x_str, "x = 123,456,789.9");
    } catch (const doxy::error& failure) { handle_failure(failure.what()); }
    if (test_passed) std::println(stderr, "pass");

    if (fails == 0) {
        std::println(stderr, "Total tests: {}, all PASSED", test_count);
    } else {
        std::println(stderr);
        std::println(stderr, "Total tests: {}, PASSED: {}, FAILED: {}", test_count, test_count - fails, fails);
        for (const auto& msg : failed_messages) std::print(stderr, "{}", msg);
    }

    // Return 1 if there were any failures, 0 otherwise.
    return fails > 0 ? 1 : 0;
}